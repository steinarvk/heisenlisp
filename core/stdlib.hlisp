(defun! list (&rest xs) xs)

(defun! + (&rest xs) (reduce-left low-level-plus 0 xs))
(defun! * (&rest xs) (reduce-left low-level-multiply 1 xs))
(defun! / (numerator &rest denominators) (low-level-divide numerator (apply * denominators)))

(defun! negate (x) (* -1 x))

(defun! - (&rest xs)
  (if (_atom-eq? 1 (length xs))
      (negate (first xs))
      (reduce-left low-level-minus 0 xs)))

(defun! empty? (xs) (nil? xs))

(defun! zero? (n) (_atom-eq? 0 n))

(defun! nil? (x) (_atom-eq? nil x))

(defun! first (xs) (car xs))
(defun! second (xs) (car (cdr xs)))
(defun! third (xs) (car (cdr (cdr xs))))

(defun! _dumb-equals? (a b)
  (_atom-eq? (_to-string a) (_to-string b)))

(defmacro! cond (clause &rest more-clauses)
  `(if ,(first clause)
       ,(second clause)
       ,(if (nil? more-clauses)
            nil
            (cons 'cond more-clauses))))

(defun! inc (n) (+ n 1))
(defun! dec (n) (- n 1))

(defun! _cons? (x) (equals? 'cons (_type x)))

(defun! uncertain? (x)
  (if (_cons? x)
      (or (uncertain? (car x))
          (uncertain? (cdr x)))
      (_uncertain? x)))
