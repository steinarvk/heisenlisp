(defun! list (&rest xs) xs)

(defun! + (&rest xs) (reduce-left low-level-plus 0 xs))
(defun! * (&rest xs) (reduce-left low-level-multiply 1 xs))
(defun! / (numerator &rest denominators)
  (if (nil? denominators)
      (/ 1 numerator)
      (low-level-divide numerator (apply * denominators))))

;; TODO: may need to become a builtin to deal with
;;       uncertainty efficiently.
(defun! fold-right (f initial xs)
  (if (nil? xs)
      initial
      (f (car xs) (fold-right f initial (cdr xs)))))

(defun! list* (arg &rest args)
  (when (uncertain? (length args))
    (throw-exception "list* does not handle unknown-length lists"))
  (if (nil? args)
      arg
      (cons arg (apply list* args))))

(let ((letfunc-binding-to-let-binding
       (lambda (binding)
         (let ((name (first binding))
               (args (second binding))
               (body (cdr (cdr binding))))
           (unless (must? (symbol? name))
             (throw-exception "wanted symbol as binding target"))
           (unless (must? (cons? args))
             (throw-exception "wanted list as argument"))
           `(,name (lambda ,args ,@body))))))
 (defmacro! letfunc (bindings &rest body)
   (when (uncertain? bindings)
     (throw-exception "letfunc bindings cannot be uncertain"))
   `(let ,(map letfunc-binding-to-let-binding bindings)
      ,@body)))

(defmacro! let* (bindings &rest body)
  (if (nil? bindings)
      `(progn ,@body)
      (let ((first-binding (first bindings))
            (rest-of-bindings (cdr bindings)))
        `(let (,first-binding) (let* ,rest-of-bindings ,@body)))))

(defmacro! letfunc* (bindings &rest body)
  (if (nil? bindings)
      `(progn ,@body)
      (let ((first-binding (first bindings))
            (rest-of-bindings (cdr bindings)))
        `(letfunc (,first-binding) (letfunc* ,rest-of-bindings ,@body)))))

;; append should probably become a builtin when we get special
;; treatment for appending unknowns. It's a very inefficient
;; implementation at the moment.
(letfunc* ((cons-replacing-tail (repl)
            (lambda (carval cdrval)
              (cons carval (if (nil? cdrval) repl cdrval))))
           (append-two (xs ys)
             (if (nil? xs)
                 ys
                 (fold-right (cons-replacing-tail ys) nil xs))))
  (defun! append (&rest lists)
    (fold-right append-two nil lists)))

(defun! partition-ternary (f xs negative-acc zero-acc positive-acc)
  (if (nil? xs)
      (list negative-acc zero-acc positive-acc)
      (let* ((item (car xs))
             (result (f item)))
        (cond
          ((must? (> result 0))
           (partition-ternary f (cdr xs) negative-acc zero-acc (cons item positive-acc)))
          ((must? (< result 0))
           (partition-ternary f (cdr xs) (cons item negative-acc) zero-acc positive-acc))
          (true
           (partition-ternary f (cdr xs) negative-acc (cons item zero-acc) positive-acc))))))

(letfunc* ((categoriser (pivot)
             (lambda (x)
               (cond
                 ((must? (> x pivot)) 1)
                 ((must? (< x pivot)) -1)
                 (true 0)))))
  (defun! sorted (xs)
    (cond
      ((nil? xs) nil)
      ((nil? (cdr xs)) xs)
      (true
        (let* ((pivot (car xs))
               (lists (partition-ternary (categoriser pivot) (cdr xs) nil nil nil))
               (smaller (first lists))
               (same (second lists))
               (larger (third lists)))
          (append (sorted smaller) (list* pivot same) (sorted larger)))))))

(defun! to-floating-point (x) (+ 0.0 x))

(defun! nan? (x)
  (let ((xs (possible-values x)))
    (and (_cons? xs) (any? _nan?  xs))))

(defun! inc (n) (+ n 1))
(defun! dec (n) (- n 1))

(defmacro! progn (&rest body) `(let () ,@body))

(defun! negate (x) (* -1 x))

(defun! - (&rest xs)
  (if (_atom-eq? 1 (length xs))
      (negate (first xs))
      (reduce-left low-level-minus 0 xs)))

(defun! empty? (xs) (nil? xs))

(defun! zero? (n) (_atom-eq? 0 n))
(set! remainder mod)

(defun! _dumb-equals? (a b)
  (_atom-eq? (_to-string a) (_to-string b)))

(defun! _maybe? (x)
  (and (= 'any-of (_type x))
       (let ((vs (possible-values x)))
         (or (= (list true false) vs)
             (= (list false true) vs)))))

(defun! even? (n) (and (integer? n) (= 0 (mod n 2))))
(defun! odd? (n) (and (integer? n) (not (even? n))))

(defun! contains? (x xs) (any? (lambda (y) (= x y)) xs))

(defun! is-equal-to (x) (lambda (y) (= x y)))
(defun! is-not-equal-to (x) (lambda (y) (not (= x y))))

(defun! factorial (n) (if (<= n 0) 1 (* n (factorial (dec n)))))
