{
  package parser

  import (
    "strings"
    "io"
    "unicode"
    "strconv"
    "errors"
    "os"
    "io/ioutil"
    "bytes"
    "fmt"
    "unicode/utf8"

    sexpr "github.com/steinarvk/heisenlisp/expr"
  )
}

SingleExpr <- rv:Expr EOF {
  return rv, nil
}

Expr <- (
    ListExpr
  / Identifier
  / String
  / Integer
  / Bool
  / Unknown
  / AnyOf
)

Bool <- "#" ("true" / "false") {
  return sexpr.Bool(string(c.text) == "#true"), nil
}
Unknown <- "#unknown" { return sexpr.FullyUnknown{}, nil }


LPAREN <- "("
RPAREN <- ")"

sp "mandatory whitespace" <- [ \t\r\n]+
_ "whitespace" <- [ \t\r\n]*

EscapedChar <- [\x00-\x1f"\\]
EscapeSequence <- SingleCharEscape / UnicodeEscape
SingleCharEscape <- ["\\/bfnrt]
UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit
HexDigit <- [0-9a-f]i

Identifier <- [a-zA-Z?!+/*.=-] [a-zA-Z0-9?!+/*.=-]* {
  return sexpr.Identifier(strings.ToLower(string(c.text))), nil
}

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  s, err := strconv.Unquote(string(c.text))
  if err != nil {
    return nil, err
  }
  return sexpr.String(s), nil
}

Integer <- [1-9] [0-9]* {
  n, err := strconv.ParseInt(string(c.text), 10, 64)
  if err != nil {
    return nil, err
  }
  return sexpr.Integer(n), nil
}

WhitespaceThenExpr <- sp rv:Expr {
  return rv, nil
}

ListExpr <- _ LPAREN _ first:Expr more:WhitespaceThenExpr* _ RPAREN {
  var rv []sexpr.Expr

  rv = append(rv, first.(sexpr.Expr))
  for _, another := range more.([]interface{}) {
    rv = append(rv, another.(sexpr.Expr))
  }

  return sexpr.ListExpr(rv), nil
}

AnyOf <- _ "#any-of" LPAREN _ first:Expr more:WhitespaceThenExpr* _ RPAREN {
  var rv []sexpr.Expr

  rv = append(rv, first.(sexpr.Expr))
  for _, another := range more.([]interface{}) {
    rv = append(rv, another.(sexpr.Expr))
  }

  return sexpr.AnyOf(rv), nil
}


EOF <- !.
