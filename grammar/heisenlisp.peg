{
  package parser

  import (
    "strings"
    "io"
    "unicode"
    "strconv"
    "errors"
    "os"
    "io/ioutil"
    "bytes"
    "fmt"
    "unicode/utf8"

  	"github.com/steinarvk/heisenlisp/types"
  
    sexpr "github.com/steinarvk/heisenlisp/expr"
  )
}

MultiExpr <- rv:WhitespaceThenExpr+ EOF {
  return rv, nil
}

SingleExpr <- rv:Expr EOF {
  return rv, nil
}

Expr <- (
    ListExpr
  / String
  / Integer
  / Identifier
  / Bool
  / Unknown
  / AnyOf
  / Nil
)

Bool <- "#" ("true" / "false") {
  return sexpr.Bool(string(c.text) == "#true"), nil
}
Unknown <- "#unknown" { return sexpr.FullyUnknown{}, nil }

Nil <- "#nil" { return sexpr.NilValue{}, nil }

LPAREN <- "("
RPAREN <- ")"

sp "mandatory whitespace" <- [ \t\r\n]+
_ "whitespace" <- [ \t\r\n]*

EscapedChar <- [\x00-\x1f"\\]
EscapeSequence <- SingleCharEscape / UnicodeEscape
SingleCharEscape <- ["\\/bfnrt]
UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit
HexDigit <- [0-9a-f]i

Identifier <- [a-zA-Z?!+/*.=_-] [a-zA-Z0-9?!+/*.=-]* {
  return sexpr.Identifier(strings.ToLower(string(c.text))), nil
}

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  s, err := strconv.Unquote(string(c.text))
  if err != nil {
    return nil, err
  }
  return sexpr.String(s), nil
}

Integer <- ( "0" / '-'? [1-9] [0-9]* ) {
  n, err := strconv.ParseInt(string(c.text), 10, 64)
  if err != nil {
    return nil, err
  }
  return sexpr.Integer(n), nil
}

WhitespaceThenExpr <- _ rv:Expr {
  return rv, nil
}

ListExpr <- _ LPAREN _ more:WhitespaceThenExpr* _ RPAREN {
  var rv []types.Value

  for _, another := range more.([]interface{}) {
    rv = append(rv, another.(types.Value))
  }

  return sexpr.WrapList(rv), nil
}

AnyOf <- _ "#any-of" LPAREN _ first:Expr more:WhitespaceThenExpr* _ RPAREN {
  var rv []types.Value

  rv = append(rv, first.(types.Value))
  for _, another := range more.([]interface{}) {
    rv = append(rv, another.(types.Value))
  }

  return sexpr.AnyOf(rv), nil
}


EOF <- !.
